# 1. Что такое Git и система контроля версий (VCS)

Git – это популярная распределённая система контроля версий исходного кода. Система контроля версий (СКВ, version control system) позволяет сохранять изменения в файлах проекта и при необходимости возвращаться к предыдущим версиям.

Проще говоря, СКВ ведёт «историю» проекта: кто и когда редактировал код, что именно изменилось. Это необходимо для совместной разработки, резервного копирования и отслеживания эволюции проекта. Git был создан Линусом Торвальдсом в 2005 году и на сегодня остаётся одним из самых популярных средств контроля версий. Практически все современные IT-команды используют Git или схожие системы для управления исходным кодом.

## Терминология и концепции Git

1. **Commit (коммит)** – зафиксированный снимок состояния проекта. Каждый коммит имеет уникальный хеш (SHA-идентификатор) и обычно сопровождается комментарием. Коммиты образуют историю проекта – цепочку изменений. Рекомендуется делать коммиты часто и с осмысленными сообщениями.
2. **Branch (ветка)** – параллельная линия коммитов. По умолчанию репозиторий имеет основную ветку (часто называемую `master` или `main`). Создавая новые ветки, разработчики могут независимо работать над функциями или исправлениями, не мешая друг другу. Затем ветки сливаются обратно в основную ветку через merge (см. ниже).
   1. Допустим, вы работаете над одним проектом, в котором есть основная ветка `main`, содержащая стабильную версию кода. Вы разрабатываете функциональность «поиск в корзине», а ваш коллега — функциональность «добавление товаров в корзину». Если все изменения сразу вносить в `main`, может возникнуть конфликт, особенно если оба изменяли один и тот же файл. Чтобы избежать этого, рекомендуется создать две отдельные ветки от main — например, `feature/cart-search` и `feature/cart-add`. Таким образом, текущее состояние ветки `main` будет скопировано в каждую из новых веток. Каждый разработчик работает в своей ветке, вносит изменения и фиксирует их с помощью коммитов. По завершении работы ветка сливается (merge) обратно в `main` — то есть изменения из этой ветки объединяются с основной веткой. Таким образом, в `main` попадают только проверенные и завершённые изменения. После этого коллега может сделать то же самое со своей веткой, и оба функционала будут успешно добавлены в `main`.
   2. **Даже если над проектом работает только один человек, рекомендуется создавать отдельные ветки для каждой новой функции или исправления**. Это позволяет изолировать изменения, упростить тестирование и при необходимости легко откатить изменения, не затрагивая основную ветку.
3. **Merge (слияние)** – процесс объединения изменений из разных веток. Если файлы изменялись в разных местах, Git объединит их автоматически. Но конфликт (merge conflict) возникает, когда в двух сливаемых ветках правились одни и те же строки кода по-разному. Тогда Git не может решить, какую версию оставить, и останавливает слияние до ручного вмешательства. Разработчик должен открыть проблемный файл, увидеть пометки `<<<<<<<` и `=======`, `>>>>>>>` от Git, и вручную выбрать нужный вариант изменений или слить оба. После этого выполняется новый коммит, фиксирующий разрешение конфликта. Конфликты – обычное дело при работе в команде, их решают путем коммуникации: чья версия правильная, либо как объединить идеи обеих версий.
   1. Например, один из примеров конфликтов – вы и ваш коллега оба изменили одну и ту же строку в одном файле, но по-разному. Когда вы попытаетесь слить ваши ветки, Git не сможет решить, какую версию оставить, и выдаст ошибку конфликта. Вам нужно будет вручную отредактировать файл, выбрать нужные изменения и завершить слияние.
4. **Репозиторий (repository)** – хранилище проекта, содержащее все файлы и историю изменений. Можно представить его как папку с проектом плюс данные Git об истории (в папке .git). Различают локальный репозиторий (на машине разработчика) и удалённый (на сервере). Обычно командная работа строится вокруг удалённого репозитория – он центральный, а у каждого участника есть локальная копия.
5. **Staging area (индекс)** – промежуточная область, куда попадают изменения после `git add`, но до `git commit`. Она позволяет подготовить набор файлов для одного коммита. _Например_, вы можете отредактировать 5 файлов, но только 3 из них добавить в индекс и закоммитить, а остальные оставить на потом.

## Работа в команде: ветки, pull request и конфликты

Работа с ветками была немного рассмотрена выше, но теперь давайте подробнее остановимся на особенностях командной работы с Git.

В командной разработке распространён подход **«GitFlow»**: как было сказано ранее, разработчики не работают напрямую в основной ветке `main`, а создают ветки функциональности (feature branches) для каждой задачи. Например, если нужно добавить новую функцию, вы создаёте ветку `feature/new-feature` от `main`, выполняете в ней коммиты. Когда работа закончена, вы публикуете ветку на сервере (`git push`) и открываете `pull request (PR)` – запрос на слияние.

**Pull request** – это способ предложить изменения для включения в основную ветку; он позволяет другим участникам просмотреть код, обсудить и запросить правки перед слиянием. После одобрения PR ветка сливается в `main` (обычно через кнопку Merge на платформе вроде GitHub/GitLab).

При слиянии ветки через PR могут возникнуть merge-конфликты, особенно если два человека правили одни и те же участки кода. Например, разработчик A переименовал функцию `foo` в `bar` в своём коммите, а разработчик B в то же время изменил тело функции `foo`. Оба изменения попали в разные ветки. При попытке слить ветку `A` и `B`, Git обнаружит конфликт в строках, где определена функция `foo`, и попросит решить конфликт вручную. Хорошей практикой считается перед открытием PR обновлять свою ветку последними изменениями из `main` (делать `git pull`), чтобы обнаружить и решить конфликты заранее.

### Пример командного workflow

Допустим, команда из 3 человек разрабатывает веб-приложение. У каждого своя задача: фронтенд, бекенд API и интеграция с базой. Каждый разработчик создает отдельную ветку: `feature/frontend-ui`, `feature/backend`, `feature/db-setup`. Они независимо коммитят изменения.

Когда готово – пушат ветку и создают pull request на слияние в `main`. Тимлид или определенный человек проводят ревью кода (code review), оставляют комментарии.

После правок PR одобряется и сливается. Затем все участники делают `git pull`, чтобы получить обновлённый `main` с работой друг друга. Таким образом, Git обеспечивает параллельную работу без конфликтов, а возникающие конфликтные ситуации решаются осознанно и контролируемо.

## Основные команды Git

1. `git init` – инициализация нового локального репозитория в текущей папке (создаётся скрытая папка `.git` с историей).
2. `git clone <URL>` – клонирование (копирование) существующего удалённого репозитория на свой компьютер. Например, `git clone https://github.com/user/proj.git` создаст папку `proj` с полным содержимым и историей.
3. `git status` – отображение статуса репозитория: какие файлы изменены, добавлены или удалены, но ещё не зафиксированы. Полезно перед коммитом, чтобы увидеть неотслеживаемые изменения.
4. `git add <файл>` – добавление (индексация) изменений в конкретном файле для последующего коммита. Можно вызывать `git add .` чтобы добавить все изменённые файлы. После `add` изменения переходят в staging area (индекс).
5. `git commit -m "сообщение"` – фиксация (сохранение) проиндексированных изменений в истории с описанием. _Каждый коммит_ – это снимок состояния файлов с коротким сообщением-комментарием. Коммит отражает логическую единицу изменений (например, _«добавлен новый модуль»_).
6. `git log` – просмотр истории коммитов. Показывает список коммитов (обычно в обратном хронологическом порядке) с их хеш-идентификаторами, автором, датой и сообщением. Позволяет изучать эволюцию проекта.
7. `git branch` – отображение списка веток или создание новой ветки. Например, `git branch new-feature` создаст новую ветку с именем new-feature. Ветка (branch) – это именованная последовательность коммитов, независимая линия разработки. Ветки позволяют параллельно работать над разными задачами.
8. `git checkout <ветка>` – переключение на указанную ветку (или коммит). Например, `git checkout new-feature` переключит репозиторий на работу с веткой new-feature. (_Эта команда часто упоминается вместе с `git branch`: одна создаёт ветку, другая позволяет на неё перейти._)
9. `git merge <ветка>` – слияние указанной ветки с текущей. Команда пытается автоматически объединить изменения из двух линий разработки. Если часть файлов изменялась в обеих ветках, Git объединит правки, либо сообщит о конфликте.
10. `git push` – отправка ваших коммитов из локальной ветки в удалённый репозиторий. Обычно вызывается как `git push origin <ветка>` для публикации изменений на сервер (например, GitHub).
11. `git pull` – получение актуальных изменений с удалённого репозитория и слияние их с вашей текущей веткой. Эквивалент двух шагов: `git fetch` (загрузка новых коммитов) + `git merge` (слияние этих коммитов в текущую ветку).
